Passwords are another interesting case. Password hashes are often cracked by brute force attacks, usually with the aid of pre-computed lists of hash values for very large sets of possible passwords (rainbow tables). The resilience of passwords to this kind of attack depends on their strength, meaning the number of possible valid password strings a cracker has to try. Strength ranges from the obvious variants of 'password' (hundreds of possibilities), to natural language words (tens of thousands) to random (e.g. 'sT8Â£bG*7z', zillions, dependent on the length and allowed characters). To quantify 'zillions', each character may have as many values as the set of allowed characters (so for ASCII alphanumeric only that's 26 + 26 + 10 = 62). This is raised to the power of the number of characters. Adding in the 20 or so special characters available on the keyboard makes it 82 to that power (about 10 times larger for an 8 character password, 100 for 16). While the numbers illustrate that length is the most important factor in random password strength, non-alphanumeric characters are also desirable. However, you might want to restrict exactly which characters you accept, depending on what external systems you are sending the data to - for instance, password managers often restrict the characters they use in generated passwords, e.g. !$%@#. Hopefully you're going to hash these passwords anyway though, so the plain-text special characters aren't going to leave your app, but for this exercise implement an input sanitization rule that allows upper and lower case ASCII letters, plus digits and the 5 special characters above. This is an arbitrary definition of a valid, though not necessarily strong, password, which should defeat many of the injection attacks (via the password field) described above. Apply this sanitization to the server-side code for login and registration pages.